<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stunt Arena — Flow Build (v4‑boosted‑fix)</title>
<meta name="description" content="3D stunt arena with smarter AI, difficulty modes, heat scaling, score sharing, strategic boost pads, and anti‑wheelie tuning." />
<style>
  :root{
    --ink:#e9f2ff; --muted:#a6b5c8; --bg:#0b1220; --hud:#0f1a2a; --line:#1f2a44;
    --good:#7bd88f; --warn:#ef476f; --nitro:#2af5a4; --shield:#b987ff;
    --pRamp:#7aa7ff; --pPlat:#b0baff; --pBank:#7ed1a2;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:#0b1220;color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  canvas{display:block}

  /* === HUD cards === */
  .hud{position:fixed; inset:10px 10px auto 10px; display:flex; gap:10px; flex-wrap:wrap; z-index:11}
  .card{background:linear-gradient(180deg,var(--hud),#0b1422); border:1px solid var(--line); border-radius:12px; padding:10px 12px; min-width:140px}
  .card h3{margin:0 0 6px; font:600 12px/1 Inter,system-ui; color:var(--muted); text-transform:uppercase; letter-spacing:.3px}
  .big{font-weight:800; font-size:24px}
  .clickable{cursor:pointer}
  #score:hover{filter:brightness(1.15)}

  .bar{height:12px; background:#0a1420; border:1px solid var(--line); border-radius:999px; overflow:hidden}
  .fill{height:100%; background:linear-gradient(90deg,#ffd166,#f5ad3a); width:0%}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; background:#11213a; border:1px solid #21355d; font-weight:700; font-size:12px}
  .heatStars{letter-spacing:1px; color:#ffd166}
  .cooltxt{font-weight:700; color:#a6b5c8; font-size:12px}

  /* === Top-right controls === */
  .controlsBar{position:fixed; top:10px; right:10px; display:flex; gap:10px; z-index:12}
  .btn{background:#102037; color:#cfe3ff; border:1px solid #2a3d63; border-radius:10px; padding:8px 12px; font-weight:800; cursor:pointer}
  .btn:hover{filter:brightness(1.1)}
  .btn:active{transform:translateY(1px)}

  /* === Mini‑map === */
  #minimap{position:fixed; top:10px; right:10px; width:220px; height:220px; border:1px solid var(--line);
           background:#0b1422cc; border-radius:12px; z-index:9; image-rendering:pixelated; pointer-events:none}
  #maplabel{position:fixed; top:12px; right:16px; z-index:10; font:700 12px/1 Inter; color:#a6b5c8; letter-spacing:.3px; pointer-events:none}

  /* === Score feed === */
  #feed{position:fixed; right:10px; bottom:10px; width:300px; max-height:44vh; overflow:hidden;
        display:flex; flex-direction:column-reverse; gap:6px; z-index:11}
  .feedItem{background:#0c1526cc; border:1px solid var(--line); border-radius:10px; padding:6px 8px; font-weight:700;
            display:flex; justify-content:space-between; transform:translateX(0); opacity:1; transition:opacity .6s, transform .6s}
  .feedItem.fade{opacity:0; transform:translateX(10px)}
  .feedPts{color:#ffd166}

  /* === Toast & overlays === */
  .toast{position:fixed; left:50%; transform:translateX(-50%); top:20px; background:#0e1a2c; border:1px solid var(--line); border-radius:10px; padding:8px 12px; display:none; z-index:12}
  .errorbar{position:fixed; left:0; top:0; padding:8px 12px; background:#6b1a1a; color:#fff; font-weight:800; display:none; z-index:100}
  #slowmo{position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); font:900 28px/1 Inter; letter-spacing:1px;
          color:#ffd166; text-shadow:0 2px 14px #000; display:none; z-index:20}

  /* === Heat tint grade === */
  #grade{position:fixed; inset:0; pointer-events:none; z-index:5;
         background:radial-gradient(ellipse 80% 60% at 50% 60%, rgba(255,120,40,0.16), rgba(0,0,0,0) 60%);
         opacity:.10; transition:opacity .25s ease}

  /* === Hint === */
  .hint{position:fixed; left:10px; bottom:10px; padding:10px 12px; border:1px solid var(--line); border-radius:10px; color:#a6b5c8; background:#0c1526cc; z-index:8}
  .kbd{display:inline-block; padding:2px 6px; border:1px solid #2a3957; border-radius:6px; background:#0c1422; font-weight:700}

  /* === Manual overlay === */
  #manual{position:fixed; inset:0; z-index:50; display:none; align-items:center; justify-content:center; background:rgba(7,10,18,0.78); backdrop-filter:saturate(110%) blur(6px)}
  .manualBox{width:min(980px,92vw); max-height:82vh; overflow:auto; background:#0e1730; border:1px solid #2a3b5a; border-radius:14px; padding:18px 20px; color:#e9f2ff}
  .manualBox h2{margin:0 0 10px; font:900 22px/1.2 Inter}
  .manualBox h3{margin:16px 0 6px; font:800 14px/1.1 Inter; color:#a6b5c8; text-transform:uppercase; letter-spacing:.4px}
  .manualBox p{margin:6px 0 8px}
  .manualGrid{display:grid; grid-template-columns:1fr 1fr; gap:10px}
  .manualBox ul{margin:6px 0 10px 18px}
  .manualBox li{margin:4px 0}
  .manualClose{position:sticky; top:0; display:flex; justify-content:flex-end; margin:-10px -10px 10px 0}
  .xbtn{background:#152444; color:#cfe3ff; border:1px solid #29406b; border-radius:8px; padding:6px 10px; cursor:pointer; font-weight:800}
</style>
</head>
<body>
<!-- top-right controls -->
<div class="controlsBar">
  <button id="btnBots" class="btn">Bots: ON</button>
  <button id="btnDiff" class="btn">Difficulty: Normal</button>
  <button id="btnHelp" class="btn">How to Play</button>
</div>

<div class="hud">
  <div class="card"><h3>Score (click to share)</h3><div class="big clickable" id="score">0</div><div id="combo" style="font-weight:700;font-size:12px;color:#cfe3ff">Combo x1.0</div></div>
  <div class="card"><h3>Speed</h3><div style="display:flex; gap:8px; align-items:baseline"><span class="big" id="speed">0</span><span style="color:#a6b5c8;font-size:12px">mph</span></div></div>
  <div class="card"><h3>Nitro</h3><div class="bar" style="width:180px"><div id="nitroFill" class="fill"></div></div></div>
  <div class="card"><h3>Airtime</h3><div class="big" id="air">0.0s</div></div>
  <div class="card"><h3>Heat</h3>
    <div class="big"><span id="heatStars" class="heatStars">☆☆☆☆☆</span></div>
    <div class="badge" id="heatBadge">Calm</div>
    <div class="cooltxt" id="coolTxt"></div>
  </div>
  <div class="card"><h3>Power</h3><div id="powerBadge" class="badge">—</div></div>
</div>

<canvas id="minimap" width="220" height="220"></canvas>
<div id="maplabel">MAP</div>

<div id="feed"></div>

<div class="hint">
  Click once to focus. <b>Controls:</b> <span class="kbd">W/S</span> gas/brake · <span class="kbd">A/D</span> steer ·
  <span class="kbd">Space</span> handbrake (drift) · <span class="kbd">Shift</span> nitro ·
  <span class="kbd">←/→</span> barrel roll in air · <span class="kbd">C</span> camera · <span class="kbd">R</span> reset (heat kept) ·
  <span class="kbd">B</span> bots · <span class="kbd">T</span> share score · <span class="kbd">H</span> help · <span class="kbd">M</span> mute
</div>

<div id="grade"></div>
<div class="toast" id="toast">Nice!</div>
<div id="slowmo">SLOW‑MO!</div>
<div id="err" class="errorbar"></div>

<!-- Manual -->
<div id="manual">
  <div class="manualBox">
    <div class="manualClose"><button id="manualClose" class="xbtn">Close ✕</button></div>
    <h2>Stunt Arena — Complete Guide</h2>
    <div class="manualGrid">
      <div>
        <h3>What is this?</h3>
        <p>Arcade‑style driving playground. Score by <b>drifting</b>, <b>airtime</b>, and <b>flips</b>. The more you score, the higher your <b>Heat</b>. Higher Heat spawns <b>smarter, faster bots</b> that chase you.</p>
        <h3>Goal</h3>
        <ul><li>Keep your <b>Combo</b> alive, climb <b>Heat</b>, don’t get tagged.</li><li>Reset keeps Heat.</li></ul>
        <h3>Core Controls</h3>
        <ul><li><b>W/S</b> throttle/brake • <b>A/D</b> steer • <b>Space</b> handbrake • <b>Shift</b> nitro • <b>←/→</b> flips in air</li>
            <li><b>R</b> reset • <b>B</b> bots • <b>C</b> camera • <b>H</b> help • <b>T</b> share</li></ul>
      </div>
      <div>
        <h3>Scoring & Boost Pads</h3>
        <ul><li><b>Drift</b> longer/cleaner = more points.</li>
            <li><b>Airtime</b> per second + <b>Flips</b> = big chunks.</li>
            <li><b>Boost Pads</b>: forward kick + nitro + brief <b>Turbo</b> power. Placed on ramp run‑ups, landings, and corner exits.</li></ul>
        <h3>Heat</h3>
        <ul><li>Earn → stars rise; idle → stars cool down one by one.</li><li><b>Inferno</b> gives the biggest multiplier and meanest bots.</li></ul>
      </div>
    </div>
  </div>
</div>

<!-- Libraries -->
<script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

<script>
(function(){
  /* ======= Errors ======= */
  const err = document.getElementById('err');
  window.addEventListener('error', e => { err.textContent = 'Script error: ' + e.message; err.style.display='block'; });
  const $ = s => document.querySelector(s);

  /* ======= Collision groups ======= */
  const GROUP_GROUND = 1, GROUP_STUNT = 2, GROUP_PLAYER = 4, GROUP_AI = 8;

  /* ======= Globals ======= */
  const ARENA_HALF = 380, CATCH_RADIUS = 4.0;
  let scene, camera, renderer, clock;
  let world, playerVehicle, chassisBody, chassisMesh, playerWheelMeshes=[];
  let keys = {};
  let cameraMode = "chase";
  let nitro = 1.0, muted = false, groundedPrev = true;
  let timeScale = 1.0, slowmoT = 0, camShake = 0;
  let botsEnabled = true;

  /* —— UI —— */
  const ui = {
    score: $("#score"), combo: $("#combo"), speed: $("#speed"), nitroFill: $("#nitroFill"),
    air: $("#air"), toast: $("#toast"), heatStars: $("#heatStars"), heatBadge: $("#heatBadge"),
    coolTxt: $("#coolTxt"), powerBadge: $("#powerBadge"), slowmo: $("#slowmo"), grade: $("#grade"),
    btnBots: $("#btnBots"), btnHelp: $("#btnHelp"), btnDiff: $("#btnDiff"),
    manual: $("#manual"), manualClose: $("#manualClose")
  };

  /* ======= Scoring ======= */
  let score=0, combo=1.0;
  let airborne=false, airTime=0, rotAccum=0, lastQuat=null, driftTimer=0;

  /* ======= Heat / Difficulty / AI scaling ======= */
  const BASE_AI = 3, MAX_HEAT = 5;
  let heat = 0, heatCharge = 0;
  let sinceScoreT = 0;
  let coolTimer = 0;
  const HEAT_COOLDOWN_BASE = 7.0;
  const HEAT_COOLDOWN_PER_STAR = 3.0;

  const DIFF = [
    { name:"Easy",   bots:+0, botCountDelta:-1, speed:0.9,  engine:0.92, steerBoost:-0.05, grip:0.96, replanMul:1.15, avoidMul:0.9 },
    { name:"Normal", bots:+0, botCountDelta: 0, speed:1.0,  engine:1.00, steerBoost: 0.00, grip:1.00, replanMul:1.00, avoidMul:1.0 },
    { name:"Hard",   bots:+0, botCountDelta:+1, speed:1.18, engine:1.20, steerBoost:+0.06, grip:1.10, replanMul:0.82, avoidMul:1.2 }
  ];
  let diff = 1;
  function heatScoreMult(){ let m = 1 + 0.25*heat; if (heat === MAX_HEAT) m += 0.75; return m; }
  function heatName(h){ return ["Calm","Noticed","Chased","Hot","Blazing","Inferno"][h] || "Calm"; }
  function targetAICount(){ const d = DIFF[diff]; return Math.max(0, Math.min(BASE_AI + heat + d.botCountDelta, aiSpawns.length)); }

  /* ======= World content ======= */
  let floorMesh, floorTex;
  let boosts=[], hoops=[], mapShapes=[];
  let pickups=[], orbs=[];
  const particles = { smoke:null, flame:null, ring:null };

  const feedEl = document.getElementById('feed');

  /* ======= Navigation ======= */
  const nav = { nodes: [], edges: [] };
  function buildNavGraph(){
    nav.nodes.length = 0; nav.edges.length = 0;
    const outerR = ARENA_HALF - 60;
    for (let i=0;i<10;i++){ const a = i*Math.PI/5; nav.nodes.push({x:Math.cos(a)*outerR, z:Math.sin(a)*outerR}); }
    const mid=230, inner=150;
    [ [ mid,0],[ 0,mid],[-mid,0],[0,-mid], [mid,mid],[-mid,mid],[-mid,-mid],[mid,-mid] ].forEach(p=>nav.nodes.push({x:p[0], z:p[1]}));
    for(let i=0;i<8;i++){ const a=i*Math.PI/4; nav.nodes.push({x:Math.cos(a)*inner, z:Math.sin(a)*inner}); }

    for (let i=0;i<nav.nodes.length;i++){
      for (let j=i+1;j<nav.nodes.length;j++){
        const a=nav.nodes[i], b=nav.nodes[j];
        const dx=a.x-b.x, dz=a.z-b.z, dist=Math.hypot(dx,dz);
        if (dist<270){ nav.edges.push({a:i,b:j,w:dist}); nav.edges.push({a:j,b:i,w:dist}); }
      }
    }
  }
  function nearestNode(x,z){
    let best=-1, bd=1e9;
    for (let i=0;i<nav.nodes.length;i++){ const n=nav.nodes[i]; const d=(n.x-x)*(n.x-x)+(n.z-z)*(n.z-z); if(d<bd){bd=d;best=i;} }
    return best;
  }
  function aStar(start, goal){
    if (start===-1 || goal===-1) return [];
    const open=[start], came=new Map(), g=new Map([[start,0]]);
    const h=(i)=>{ const n=nav.nodes[i], gN=nav.nodes[goal]; return Math.hypot(n.x-gN.x, n.z-gN.z); };
    const f=(i)=> (g.get(i)||1e9)+h(i);
    while(open.length){
      open.sort((i,j)=>f(i)-f(j));
      const cur=open.shift();
      if (cur===goal){ const path=[cur]; let k=cur; while(came.has(k)){ k=came.get(k); path.push(k); } return path.reverse(); }
      for (const e of nav.edges.filter(e=>e.a===cur)){
        const alt=(g.get(cur)||1e9)+e.w;
        if (alt < (g.get(e.b)||1e9)){ came.set(e.b, cur); g.set(e.b, alt); if (!open.includes(e.b)) open.push(e.b); }
      }
    }
    return [];
  }

  /* ======= Minimap ======= */
  const map = {
    el: document.getElementById("minimap"),
    ctx: document.getElementById("minimap").getContext("2d"),
    w: 220, h: 220,
    toX(x){ return ( (x + ARENA_HALF) / (ARENA_HALF*2) ) * this.w; },
    toY(z){ return this.h - ( (z + ARENA_HALF) / (ARENA_HALF*2) ) * this.h; },
    drawCarIcon(x,z,yaw,color,hi=false){
      const ctx=this.ctx, px=this.toX(x), py=this.toY(z);
      const L=14,W=8; ctx.save(); ctx.translate(px,py); ctx.rotate(-yaw);
      ctx.fillStyle=color; ctx.globalAlpha=.95; ctx.fillRect(-L/2,-W/2,L,W);
      ctx.beginPath(); ctx.moveTo(L/2,0); ctx.lineTo(L/2-5,-W/2); ctx.lineTo(L/2-5,W/2); ctx.closePath(); ctx.fill();
      ctx.strokeStyle="#fff"; ctx.globalAlpha=.8; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(L/2+1,0); ctx.lineTo(L/2+5,0); ctx.stroke();
      if(hi){ ctx.globalAlpha=.6; ctx.strokeStyle="#7bd88f"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,(L+4)/2,0,Math.PI*2); ctx.stroke();}
      ctx.restore();
    },
    draw(){
      const ctx=this.ctx, w=this.w, h=this.h;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle="#0c1526"; ctx.fillRect(0,0,w,h);
      ctx.strokeStyle="#2a3b5a"; ctx.lineWidth=2; ctx.strokeRect(2,2,w-4,h-4);
      const s = w/(ARENA_HALF*2);
      for(const r of mapShapes){
        ctx.save(); ctx.translate(this.toX(r.x), this.toY(r.z)); ctx.rotate(-r.yaw);
        ctx.globalAlpha=r.alpha??0.35; ctx.fillStyle=r.color||"#6a82c2";
        ctx.fillRect(-(r.w*s)/2, -(r.d*s)/2, r.w*s, r.d*s); ctx.restore();
      }
      ctx.fillStyle = "#2af5a4"; for (const b of boosts){ const x=this.toX(b.pos.x), y=this.toY(b.pos.z); ctx.fillRect(x-3,y-3,6,6); }
      ctx.fillStyle = "#f5ad3a"; for (const h2 of hoops){ const x=this.toX(h2.pos.x), y=this.toY(h2.pos.z); ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); }
      for (const p of pickups){
        const x=this.toX(p.mesh.position.x), y=this.toY(p.mesh.position.z);
        ctx.fillStyle = (p.type==='nitro') ? "#2af5a4" : "#b987ff";
        ctx.globalAlpha = p.mesh.visible ? 0.9 : 0.3; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
      }
      ctx.fillStyle="#ad76ff";
      for (const o of orbs){ const x=this.toX(o.position.x), y=this.toY(o.position.z); ctx.fillRect(x-2,y-2,4,4); }
      const pf = forwardVector(chassisBody);
      this.drawCarIcon(chassisBody.position.x, chassisBody.position.z, Math.atan2(pf.x,pf.z), "#7bd88f", true);
      for (const ai of aiCars){ const f=forwardVector(ai.body); this.drawCarIcon(ai.body.position.x, ai.body.position.z, Math.atan2(f.x,f.z), "#ef476f", false); }
      ctx.globalAlpha=1;
    }
  };

  /* ======= Feed ======= */
  function pushFeed(label, pts){
    const item = document.createElement('div');
    item.className='feedItem';
    item.innerHTML = `<span>${label}</span><span class="feedPts">+${Math.round(pts)}</span>`;
    feedEl.appendChild(item);
    setTimeout(()=> item.classList.add('fade'), 1400);
    setTimeout(()=> item.remove(), 2200);
  }

  /* ======= Particles ======= */
  function makeCircleTexture(inner, outer){
    const c=document.createElement('canvas'); c.width=c.height=64;
    const g=c.getContext('2d'); const grd=g.createRadialGradient(32,32,1,32,32,32);
    grd.addColorStop(0, inner); grd.addColorStop(1, outer); g.fillStyle=grd; g.beginPath(); g.arc(32,32,32,0,Math.PI*2); g.fill();
    const t = new THREE.CanvasTexture(c); t.needsUpdate=true; return t;
  }
  function createSpritePool(tex, max, blending){
    const group = new THREE.Group(); scene && scene.add(group);
    const pool = []; const active=[];
    for(let i=0;i<max;i++){
      const m = new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false, blending });
      const s = new THREE.Sprite(m); s.visible=false; s.userData={life:0,maxLife:1,vel:new THREE.Vector3(),size0:1};
      group.add(s); pool.push(s);
    }
    return {
      pool, active, group,
      spawn(pos, vel, life, size, opacity=1){
        const s = pool.pop(); if(!s) return;
        s.position.copy(pos); s.userData.vel.copy(vel); s.userData.life=life; s.userData.maxLife=life; s.userData.size0=size;
        s.scale.set(size,size,1); s.material.opacity=opacity; s.visible=true; active.push(s);
      },
      update(dt){
        for (let i=active.length-1;i>=0;i--){
          const s=active[i]; s.userData.life -= dt;
          if (s.userData.life<=0){ s.visible=false; active.splice(i,1); pool.push(s); continue; }
          s.position.addScaledVector(s.userData.vel, dt);
          s.userData.vel.multiplyScalar(0.98);
          const a = s.userData.life / s.userData.maxLife;
          s.material.opacity = Math.max(0, Math.min(1, a));
          const sc = s.userData.size0 * (1 + (1-a)*0.6); s.scale.set(sc,sc,1);
        }
      }
    };
  }

  /* ======= Audio ======= */
  const audio = (() => {
    let ctx=null, osc=null, gain=null;
    const mk = () => { if(!ctx) ctx=new (window.AudioContext||window.webkitAudioContext)(); };
    const engine = (p=0,v=0)=>{ if (muted) return; mk(); if(!osc){osc=ctx.createOscillator(); gain=ctx.createGain(); osc.type="sawtooth"; gain.gain.value=0; osc.connect(gain).connect(ctx.destination); osc.start();} osc.frequency.value=80+300*p; gain.gain.value=Math.min(0.2,v); };
    const blip=(f=220,t=0.08,v=0.2)=>{ if (muted) return; mk(); const o=ctx.createOscillator(), g=ctx.createGain(); o.type="triangle"; o.frequency.value=f; g.gain.value=v; o.connect(g).connect(ctx.destination); o.start(); o.stop(ctx.currentTime + t); };
    return { engine, blip };
  })();

  /* ======= Three ======= */
  function initThree(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1220);
    scene.fog = new THREE.Fog(0x0b1220, 120, 700);

    camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0, 5, -10);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xcfe6ff, 0x223344, 0.6); scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(80,120,-40);
    sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); sun.shadow.camera.near=10; sun.shadow.camera.far=700; scene.add(sun);

    clock = new THREE.Clock();
    addEventListener("resize", ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

    // particles
    particles.smoke = createSpritePool(makeCircleTexture('rgba(160,170,190,0.9)','rgba(20,30,50,0.0)'), 150, THREE.NormalBlending);
    particles.flame = createSpritePool(makeCircleTexture('rgba(255,200,90,0.95)','rgba(255,80,0,0.0)'), 70, THREE.AdditiveBlending);
    particles.ring  = createSpritePool(makeCircleTexture('rgba(255,160,60,0.9)','rgba(255,80,0,0.0)'), 16, THREE.AdditiveBlending);
  }

  /* ======= Physics & World ======= */
  function initPhysics(){
    world = new CANNON.World(); world.gravity.set(0,-9.82,0);
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.allowSleep = false;
    world.defaultContactMaterial.friction = 0.5;

    const groundMat  = new CANNON.Material("ground");
    const wheelMat   = new CANNON.Material("wheel");
    const chassisMat = new CANNON.Material("chassis");
    world.addContactMaterial(new CANNON.ContactMaterial(groundMat, wheelMat,  { friction:0.95, restitution:0.0 }));
    world.addContactMaterial(new CANNON.ContactMaterial(groundMat, chassisMat,{ friction:0.3, restitution:0.0 }));

    // ground
    const ground = new CANNON.Body({ mass:0, material: groundMat });
    ground.addShape(new CANNON.Plane());
    ground.quaternion.setFromEuler(-Math.PI/2, 0, 0);
    ground.collisionFilterGroup = GROUP_GROUND;
    ground.collisionFilterMask  = GROUP_PLAYER | GROUP_AI | GROUP_STUNT;
    world.addBody(ground);

    // visual floor (animated)
    floorTex = gridTexture(); floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping; floorTex.repeat.set(80,80);
    floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(ARENA_HALF*2.1,ARENA_HALF*2.1),
                               new THREE.MeshStandardMaterial({ map:floorTex, color:0x253a57, roughness:1 }));
    floorMesh.rotation.x = -Math.PI/2; floorMesh.receiveShadow = true; scene.add(floorMesh);

    // walls (AI collides)
    addBoxStatic(ARENA_HALF*2-20, 12, 5, [0,6,-ARENA_HALF], [0,0,0], 0x2b3f5c, {collideAI:true});
    addBoxStatic(ARENA_HALF*2-20, 12, 5, [0,6, ARENA_HALF], [0,0,0], 0x2b3f5c, {collideAI:true});
    addBoxStatic(5, 12, ARENA_HALF*2-20, [-ARENA_HALF,6,0], [0,0,0], 0x2b3f5c, {collideAI:true});
    addBoxStatic(5, 12, ARENA_HALF*2-20, [ ARENA_HALF,6,0], [0,0,0], 0x2b3f5c, {collideAI:true});

    // playground
    buildStuntSet();

    // nav graph
    buildNavGraph();

    // pickups + orbs
    spawnPickups();
    spawnOrbs(16);
  }

  function gridTexture(){
    const c=document.createElement("canvas"); c.width=c.height=256; const x=c.getContext("2d");
    x.fillStyle="#0c1626"; x.fillRect(0,0,256,256);
    x.strokeStyle="#22324d"; x.lineWidth=2;
    for(let i=0;i<=16;i++){ const p=(i/16)*256; x.beginPath(); x.moveTo(p,0); x.lineTo(p,256); x.stroke(); x.beginPath(); x.moveTo(0,p); x.lineTo(256,p); x.stroke(); }
    x.strokeStyle="#2e446b"; x.lineWidth=3;
    for(let i=0;i<=4;i++){ const p=(i/4)*256; x.beginPath(); x.moveTo(p,0); x.lineTo(p,256); x.stroke(); x.beginPath(); x.moveTo(0,p); x.lineTo(256,p); x.stroke(); }
    return new THREE.CanvasTexture(c);
  }

  function addBoxStatic(w,h,d,pos,rot=[0,0,0],color=0x2b3f5c,opts={collideAI:false}){
    const body=new CANNON.Body({mass:0}); body.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2)));
    body.position.set(...pos); body.quaternion.setFromEuler(...rot,"XYZ");
    body.collisionFilterGroup = GROUP_STUNT;
    body.collisionFilterMask  = GROUP_PLAYER | (opts.collideAI ? GROUP_AI : 0) | GROUP_GROUND;
    world.addBody(body);
    const mesh=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({ color, roughness:0.9 }));
    mesh.position.set(...pos); mesh.rotation.set(...rot); mesh.receiveShadow=true;
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color:0x6ac6ff, transparent:true, opacity:0.28 }));
    mesh.add(line);
    scene.add(mesh);
    return {body, mesh};
  }

  function addBoostPad(sizeX,sizeZ,pos,rot=[0,0,0]){
    const m=new THREE.Mesh(new THREE.PlaneGeometry(sizeX,sizeZ), new THREE.MeshBasicMaterial({ color:0x2af5a4, transparent:true, opacity:0.88 }));
    m.rotation.set(-Math.PI/2+rot[0], rot[1], rot[2]); m.position.set(...pos); m.renderOrder=2; scene.add(m);
    const pad={ pos:new THREE.Vector3(...pos), size:new THREE.Vector2(sizeX,sizeZ), rotY:rot[1]||0, cool:0 };
    boosts.push(pad);
  }
  function addHoop(radius, thickness, pos){
    const geo=new THREE.TorusGeometry(radius, thickness, 16, 64);
    const mesh=new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color:0xffb366, emissive:0x553300, roughness:0.4, metalness:0.3 }));
    mesh.position.set(...pos); mesh.rotation.x=Math.PI/2; mesh.castShadow=true; scene.add(mesh);
    hoops.push({ pos:new THREE.Vector3(...pos), radius, thickness, mesh, scored:false });
  }

  function buildStuntSet(){
    mapShapes.length = 0; boosts.length = 0; hoops.length = 0;

    // FLOW LINE A (center north-south): gentle kicker -> tabletop -> kicker -> hoop
    addStuntRect(48,2.0,92,[0,1,-40],[Math.PI/16,0,0],0x365a83,"ramp");
    addStuntRect(28,2.0,36,[0,3,-2],[0,0,0],0x314861,"plat");
    addStuntRect(48,2.0,92,[0,1,34],[-Math.PI/18,0,0],0x365a83,"ramp");
    addHoop(10,1.2,[0,14,18]);

    // FLOW LINE B (east): kicker -> hoop
    addStuntRect(42,1.8,70,[160,1,30],[Math.PI/16,0,0],0x3b5a84,"ramp");
    addHoop(9,1.1,[160,13,78]);

    // FLOW LINE C (west wave ramps): chain drifts
    for (let i=0;i<4;i++){ addStuntRect(24,1.5,18,[-180 + i*40,0.8,80],[Math.PI/14,0,0],0x3a4f7d,"ramp"); }

    // Banked corners
    addStuntRect(90,3.0,40,[-260,2,-260],[0, Math.PI/4,  Math.PI/8],0x305b52,"bank");
    addStuntRect(90,3.0,40,[ 260,2, 260],[0,-3*Math.PI/4,-Math.PI/8],0x305b52,"bank");

    // Tabletops / bridge (north)
    addStuntRect(14,1.4,20,[ 70,0.7,160],[Math.PI/14,0,0],0x3b5a84,"ramp");
    addStuntRect( 6,1.0,60,[  0,4.5,160],[0,0,0],0x5c6fe0,"plat");
    addStuntRect(14,1.4,20,[-70,0.7,160],[-Math.PI/14,0,0],0x3b5a84,"ramp");

    // Extra hoops—reachable with pad or nitro
    addHoop(8,1.0,[120,13,40]); addHoop(8,1.0,[-120,13,-40]);

    /* ===== Strategic boost pads (moved away from spawn) =====
       - No pads within ~40m of spawn.
       - Pads before ramp entries, after landings, and on bank exits.
    */
    // Flow A entries/landings
    addBoostPad(16,22,[  0,0.06, -64],[0,0,0]);  // before first kicker
    addBoostPad(16,22,[  0,0.06,  10],[0,0,0]);  // bridge to second kicker
    addBoostPad(16,22,[  0,0.06,  72],[0,0,0]);  // post‑landing chain

    // East line run-up and exit
    addBoostPad(16,22,[140,0.06,-40],[0,0,0]);
    addBoostPad(16,22,[152,0.06,   8],[0,0,0]);
    addBoostPad(16,22,[160,0.06,  96],[0,0,0]);  // after hoop landing

    // West waves: keep surfing speed
    addBoostPad(16,20,[-200,0.06, 50],[0,0,0]);
    addBoostPad(16,20,[-160,0.06, 90],[0,0,0]);

    // North bridge entry
    addBoostPad(12,18,[   0,0.06,140],[0,0,0]);

    // Banked corner exits (diagonal to center)
    addBoostPad(18,18,[-230,0.06,-210],[0, Math.PI/4, 0]);
    addBoostPad(18,18,[ 230,0.06, 210],[0,-3*Math.PI/4,0]);

    // Outer midlines for chase chains
    addBoostPad(18,18,[-120,0.06,  0],[0,0,0]);
    addBoostPad(18,18,[ 120,0.06,  0],[0,0,0]);
  }

  function addStuntRect(w,h,d,pos,rot,color,type){
    addBoxStatic(w,h,d,pos,rot,color,{collideAI:false});
    const mapColor = type==="ramp"?varGet('--pRamp'):type==="plat"?varGet('--pPlat'):type==="bank"?varGet('--pBank'):"#6a82c2";
    pushMapRect(w,d,pos,rot,mapColor,type==="plat"?0.25:0.35,type);
  }
  function pushMapRect(w,d,pos,rot,color,alpha=0.35,type="ramp"){
    const yaw=(rot&&rot[1])?rot[1]:0; mapShapes.push({x:pos[0],z:pos[2],w,d,yaw,color,alpha,type});
  }
  function varGet(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  /* ======= Player ======= */
  let shieldT = 0, shieldMesh;
  let turboT = 0; // brief turbo after boost pad
  function buildPlayer(){
    chassisBody = new CANNON.Body({ mass:550, material: new CANNON.Material("chassis") });
    chassisBody.addShape(new CANNON.Box(new CANNON.Vec3(1.0,0.35,2.1)), new CANNON.Vec3(0,-0.25,0)); // lower COM
    chassisBody.position.set(0,3,-140);
    chassisBody.angularDamping=0.5; chassisBody.allowSleep = false;
    chassisBody.collisionFilterGroup = GROUP_PLAYER;
    chassisBody.collisionFilterMask  = GROUP_GROUND | GROUP_STUNT | GROUP_AI;
    world.addBody(chassisBody);

    chassisMesh = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.7,4.2),
                  new THREE.MeshStandardMaterial({ color:0x66b3ff, metalness:0.35, roughness:0.5 }));
    chassisMesh.castShadow = true; scene.add(chassisMesh);
    const roof = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.5,1.6),
                  new THREE.MeshStandardMaterial({ color:0x99d1ff, metalness:0.2, roughness:0.6 }));
    roof.position.set(0,0.6,-0.3); chassisMesh.add(roof);

    // Shield visual
    shieldMesh = new THREE.Mesh(new THREE.TorusGeometry(1.6,0.06,16,64),
                   new THREE.MeshBasicMaterial({ color:0xb987ff, transparent:true, opacity:0.6 }));
    shieldMesh.rotation.x = Math.PI/2; shieldMesh.visible=false; chassisMesh.add(shieldMesh);

    playerVehicle = new CANNON.RaycastVehicle({ chassisBody, indexRightAxis:0, indexUpAxis:1, indexForwardAxis:2 });

    const wheelOptions = {
      radius: 0.45, directionLocal:new CANNON.Vec3(0,-1,0),
      suspensionStiffness: 40, suspensionRestLength: 0.32,
      frictionSlip: 9.5, dampingRelaxation: 2.7, dampingCompression: 4.4,
      maxSuspensionForce: 1e5, rollInfluence: 0.02,
      axleLocal: new CANNON.Vec3(-1,0,0), maxSuspensionTravel: 0.33,
      customSlidingRotationalSpeed: -30, useCustomSlidingRotationalSpeed: true
    };
    const axleW=1.2, wheelBase=1.8;
    [new CANNON.Vec3(-axleW,-0.25, wheelBase),
     new CANNON.Vec3( axleW,-0.25, wheelBase),
     new CANNON.Vec3(-axleW,-0.25,-wheelBase),
     new CANNON.Vec3( axleW,-0.25,-wheelBase)]
      .forEach((p,idx) => playerVehicle.addWheel({ ...wheelOptions, rollInfluence: idx<2?0.015:0.02, chassisConnectionPointLocal: p }));
    playerVehicle.addToWorld(world);

    const wGeo=new THREE.CylinderGeometry(wheelOptions.radius,wheelOptions.radius,0.28,20); wGeo.rotateZ(Math.PI/2);
    const wMat=new THREE.MeshStandardMaterial({ color:0x223243, roughness:0.8 });
    for(let i=0;i<4;i++){ const w=new THREE.Mesh(wGeo,wMat); w.castShadow=true; scene.add(w); playerWheelMeshes.push(w); }
  }

  /* ======= AI ======= */
  const aiCars = [];
  const aiSpawns = [
    {x:  90, z:  90, color:0xff7777}, {x: -130, z: 80, color:0xff7777}, {x:  140, z:-100, color:0xff7777},
    {x:  260, z:  20, color:0xff7777}, {x:-240, z:-60, color:0xff7777}, {x:   40, z: 260, color:0xff7777},
    {x: -60, z:-240, color:0xff7777}, {x:  240, z:-220, color:0xff7777}
  ];
  function buildAICar(spawn, role="pursue"){
    const body = new CANNON.Body({ mass:540 });
    body.addShape(new CANNON.Box(new CANNON.Vec3(1.0,0.35,2.1)), new CANNON.Vec3(0,-0.25,0));
    body.position.set(spawn.x, 3, spawn.z);
    body.angularDamping = 0.55; body.allowSleep = false;
    body.collisionFilterGroup = GROUP_AI;
    body.collisionFilterMask  = GROUP_GROUND | GROUP_PLAYER | GROUP_STUNT;
    world.addBody(body);

    const mesh = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.7,4.2),
                  new THREE.MeshStandardMaterial({ color: spawn.color||0xff7777, metalness:0.2, roughness:0.6 }));
    mesh.castShadow = true; scene.add(mesh);

    const veh = new CANNON.RaycastVehicle({ chassisBody: body, indexRightAxis:0, indexUpAxis:1, indexForwardAxis:2 });
    const wheelOptions = { radius:0.45, directionLocal:new CANNON.Vec3(0,-1,0), suspensionStiffness:38, suspensionRestLength:0.32, frictionSlip:10.2, dampingRelaxation: 2.6, dampingCompression: 4.4, maxSuspensionForce:1e5, rollInfluence:0.02, axleLocal:new CANNON.Vec3(-1,0,0), maxSuspensionTravel:0.33, customSlidingRotationalSpeed:-30, useCustomSlidingRotationalSpeed:true };
    const axleW=1.2, wheelBase=1.8;
    [new CANNON.Vec3(-axleW,-0.25, wheelBase), new CANNON.Vec3( axleW,-0.25, wheelBase),
     new CANNON.Vec3(-axleW,-0.25,-wheelBase),new CANNON.Vec3( axleW,-0.25,-wheelBase)]
      .forEach((p,idx) => veh.addWheel({ ...wheelOptions, rollInfluence: idx<2?0.015:0.02, chassisConnectionPointLocal: p }));
    veh.addToWorld(world);

    const wGeo=new THREE.CylinderGeometry(wheelOptions.radius,wheelOptions.radius,0.28,20); wGeo.rotateZ(Math.PI/2);
    const wMat=new THREE.MeshStandardMaterial({ color:0x552222, roughness:0.8 });
    const wheels=[]; for(let i=0;i<4;i++){ const w=new THREE.Mesh(wGeo,wMat); w.castShadow=true; scene.add(w); wheels.push(w); }

    return { body, mesh, veh, wheels, spawn, stuckT:0, role, steerLP:0, repathT:0, path:[], pathIdx:0 };
  }
  function spawnAI(){
    if (!botsEnabled) return;
    const roles = ["pursue","flankL","flankR","pursue"];
    const sp = aiSpawns[Math.floor(Math.random()*aiSpawns.length)];
    const role = roles[Math.floor(Math.random()*roles.length)];
    aiCars.push(buildAICar(sp, role));
  }
  function despawnAI(){
    if (!aiCars.length) return;
    const ai = aiCars.pop();
    ai.veh.removeFromWorld(world); world.removeBody(ai.body);
    scene.remove(ai.mesh); for (const w of ai.wheels) scene.remove(w);
  }
  function reconcileBotsToHeat(){ const want = targetAICount(); while (aiCars.length < want) spawnAI(); while (aiCars.length > want) despawnAI(); }

  /* ======= Utilities ======= */
  function forwardVector(body){
    const q=new THREE.Quaternion(body.quaternion.x,body.quaternion.y,body.quaternion.z,body.quaternion.w);
    const f=new THREE.Vector3(0,0,1).applyQuaternion(q); return {x:f.x,y:f.y,z:f.z};
  }
  function rightVector(body){
    const q=new THREE.Quaternion(body.quaternion.x,body.quaternion.y,body.quaternion.z,body.quaternion.w);
    const r=new THREE.Vector3(1,0,0).applyQuaternion(q); return {x:r.x,y:r.y,z:r.z};
  }
  function flash(text){ const el=ui.toast; el.textContent=text; el.style.display="block"; clearTimeout(flash._t); flash._t=setTimeout(()=>el.style.display="none", 1000); }
  function pushRing(pos, size){ particles.ring.spawn(new THREE.Vector3(pos.x,pos.y+0.3,pos.z), new THREE.Vector3(0,0,0), 0.6, size, 0.9); }

  function addScore(pts, label){
    const gain = Math.round(pts * combo * heatScoreMult());
    score += gain; ui.score.textContent = score.toLocaleString();
    if (label){ flash(`${label} +${gain}`); pushFeed(label, gain); }
    heatCharge = Math.min(1, heatCharge + gain * 0.00045);
    sinceScoreT = 0;
  }

  /* ======= AI obstacle awareness ======= */
  function aiAvoidSteer(ai){
    let steerBias = 0;
    const px = ai.body.position.x, pz = ai.body.position.z;
    for (const r of mapShapes){
      const c = Math.cos(-r.yaw), s = Math.sin(-r.yaw);
      const dx = px - r.x, dz = pz - r.z;
      const lx = dx*c - dz*s, lz = dx*s + dz*c;
      const hw = r.w/2 + 8, hd = r.d/2 + 8;
      const clx = Math.max(-hw, Math.min(hw, lx));
      const clz = Math.max(-hd, Math.min(hd, lz));
      const offx = lx - clx, offz = lz - clz;
      const wx = offx*c + offz*s, wz = -offx*s + offz*c;
      const mag = Math.hypot(wx, wz);
      if (mag > 0){
        const f = forwardVector(ai.body);
        const dot = f.x*wx + f.z*wz, cross = f.x*wz - f.z*wx;
        const ang = Math.atan2(cross, dot);
        const typeWeight = (r.type==='ramp'?1.0:(r.type==='bank'?0.8:0.5));
        const near = 1/(1+mag*0.08);
        const heatK = 0.6 + 0.08*heat;
        const diffMul = DIFF[diff].avoidMul;
        steerBias += Math.max(-1, Math.min(1, ang)) * near * 0.7 * typeWeight * heatK * diffMul;
      }
    }
    // border guard
    const margin=28;
    if (ARENA_HALF - Math.abs(px) < margin || ARENA_HALF - Math.abs(pz) < margin){
      const vx = -px, vz = -pz;
      const f = forwardVector(ai.body);
      const dot = f.x*vx + f.z*vz, cross = f.x*vz - f.z*vx;
      const ang = Math.atan2(cross, dot);
      steerBias += Math.max(-0.7, Math.min(0.7, ang)) * 0.7;
    }
    return { steer: steerBias };
  }

  /* ======= Heat UI & scaling ======= */
  function updateHeat(dt){
    sinceScoreT += dt;
    const coolDelay = HEAT_COOLDOWN_BASE + HEAT_COOLDOWN_PER_STAR * heat;
    if (sinceScoreT >= 1 && heat > 0) {
      if (coolTimer <= 0) coolTimer = coolDelay; else coolTimer = Math.max(0, coolTimer - dt);
      ui.coolTxt.textContent = `Cooling in: ${coolTimer.toFixed(1)}s`;
      if (coolTimer <= 0){ heat = Math.max(0, heat - 1); onHeatChange(); coolTimer = heat>0 ? (HEAT_COOLDOWN_BASE + HEAT_COOLDOWN_PER_STAR * heat) : 0; }
    } else { ui.coolTxt.textContent = ""; coolTimer = 0; }

    if (sinceScoreT > 0.3) heatCharge = Math.max(0, heatCharge - dt*0.12);
    if (heat < MAX_HEAT && heatCharge >= 1){ heat++; heatCharge -= 1; onHeatChange(); }

    ui.heatStars.textContent = "★".repeat(heat) + "☆".repeat(MAX_HEAT-heat);
    ui.heatBadge.textContent = heatName(heat);
  }
  function onHeatChange(){ pushRing(chassisBody.position, 4 + heat*0.8); reconcileBotsToHeat(); if (heat === MAX_HEAT){ flash("Inferno! Score Multiplier ↑"); audio.blip(760,.18,.25);} }

  function infernoSpike(){ return heat===MAX_HEAT ? 1.18 : 1.0; }
  function aiTargetSpeed(){ return (26 + heat*7) * DIFF[diff].speed * infernoSpike(); }
  function aiSteerClamp(){ return (0.55 + heat*0.07 + DIFF[diff].steerBoost); }
  function aiEngineBase(){ return - (3600 + heat*520) * DIFF[diff].engine * infernoSpike(); }
  function aiRepathBase(){ return Math.max(0.18, (0.72 - heat*0.12) * DIFF[diff].replanMul); }
  function aiLeadFactor(dist, v){ return Math.min(1.6, dist / (v + 1)) * (1 + 0.22*heat); }

  /* ======= Pickups / Orbs ======= */
  function spawnPickups(){
    for (let i=0;i<3;i++) pickups.push(makePickup('nitro', randomEdgePos()));
    pickups.push(makePickup('shield', randomEdgePos()));
  }
  function makePickup(type, pos){
    const geo = type==='nitro' ? new THREE.CylinderGeometry(0.6,0.6,1.2,14) : new THREE.TorusGeometry(1.0,0.15,12,32);
    const mat = new THREE.MeshStandardMaterial({ color: type==='nitro' ? 0x2af5a4 : 0xb987ff, emissive: type==='nitro' ? 0x0d5 : 0x321055, roughness:0.2, metalness:0.1 });
    const m = new THREE.Mesh(geo, mat); m.position.set(pos.x, type==='nitro'?0.9:1.2, pos.z); m.castShadow=true; scene.add(m);
    return { mesh: m, type, respawnT: 0 };
  }
  function randomEdgePos(){ const r = ARENA_HALF-40; const a = Math.random()*Math.PI*2; const rad = r - 40*Math.random(); return new THREE.Vector3(Math.cos(a)*rad, 0, Math.sin(a)*rad); }
  function spawnOrbs(n){
    for (let i=0;i<n;i++){
      const m = new THREE.Mesh(new THREE.SphereGeometry(0.5,12,12), new THREE.MeshStandardMaterial({ color:0xad76ff, emissive:0x220033, roughness:0.4 }));
      const p = randomEdgePos(); m.position.set(p.x,0.5,p.z); scene.add(m); orbs.push(m);
    }
  }
  function spinPickups(dt){ for (const p of pickups){ p.mesh.rotation.y += dt*1.6; p.mesh.visible = p.respawnT<=0; if (p.respawnT>0) p.respawnT -= dt; } }
  function checkPickups(){
    for (const p of pickups){
      if (!p.mesh.visible) continue;
      const dx = p.mesh.position.x - chassisBody.position.x, dz = p.mesh.position.z - chassisBody.position.z;
      if (Math.hypot(dx,dz) < 2.4){
        if (p.type==='nitro'){ nitro = Math.min(1, nitro + 0.6); addScore(200, "Nitro can"); audio.blip(660,.1,.25); }
        if (p.type==='shield'){ shieldT = 6.0; addScore(300, "Shield"); audio.blip(480,.15,.25); }
        p.respawnT = 8 + Math.random()*6; p.mesh.position.copy(randomEdgePos()); p.mesh.visible=false;
      }
    }
  }
  function checkOrbs(){
    for (let i=orbs.length-1;i>=0;i--){
      const o = orbs[i]; const dx=o.position.x - chassisBody.position.x, dz=o.position.z - chassisBody.position.z;
      if (Math.hypot(dx,dz) < 2.0){
        addScore(120, "Orb"); audio.blip(560,.07,.2);
        particles.ring.spawn(new THREE.Vector3(o.position.x,1.0,o.position.z), new THREE.Vector3(0,0,0), 0.35, 1.2, 0.9);
        scene.remove(o); orbs.splice(i,1);
      }
    }
    if (orbs.length < 12){ spawnOrbs(3); }
  }

  /* ======= Input ======= */
  addEventListener("keydown", e => {
    const k=e.key.toLowerCase(); keys[k]=true;
    if([" ","arrowup","arrowdown","arrowleft","arrowright"].includes(k)) e.preventDefault();
    if(k==="w"||k==="s"||k==="arrowup"||k==="arrowdown"){ chassisBody.wakeUp(); }
    if(k==="c"){ cameraMode = (cameraMode==="chase") ? "orbit" : "chase"; }
    if(k==="m"){ muted = !muted; }
    if(k==="r"){ resetRound("Reset"); }
    if(k==="h"){ ui.manual.style.display = (ui.manual.style.display==="flex" ? "none" : "flex"); }
    if(k==="b"){ toggleBots(); }
    if(k==="t"){ shareScore(); }
  });
  addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });
  ui.btnHelp.onclick = ()=>{ ui.manual.style.display="flex"; };
  ui.manualClose.onclick = ()=>{ ui.manual.style.display="none"; };
  ui.btnBots.onclick = ()=> toggleBots();
  ui.btnDiff.onclick = ()=> cycleDiff();
  ui.score.addEventListener('click', shareScore);

  function toggleBots(){
    botsEnabled = !botsEnabled;
    ui.btnBots.textContent = 'Bots: ' + (botsEnabled ? 'ON' : 'OFF');
    if (!botsEnabled){ while (aiCars.length) despawnAI(); }
    else { reconcileBotsToHeat(); }
  }
  function cycleDiff(){
    diff = (diff + 1) % DIFF.length;
    ui.btnDiff.textContent = 'Difficulty: ' + DIFF[diff].name;
    reconcileBotsToHeat();
  }

  function shareScore(){
    const msg = `I scored ${score.toLocaleString()} in Stunt Arena at ${heatName(heat)} heat on ${DIFF[diff].name}!`;
    const shareData = { title: "Stunt Arena", text: msg, url: location.href };
    if (navigator.share){
      navigator.share(shareData).catch(()=>{ /* ignore */ });
    } else {
      const ta=document.createElement('textarea'); ta.value = msg + " — " + location.href;
      document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      flash("Score copied! Paste to share.");
    }
  }

  function readGamepad(){
    const gp = navigator.getGamepads ? navigator.getGamepads()[0] : null;
    if (!gp) return null;
    const ax = (i)=> gp.axes[i]||0, bt = (i)=> (gp.buttons[i] && gp.buttons[i].pressed) ? 1 : 0;
    const rt = gp.axes[5]!==undefined ? (ax(5)+1)/2 : (gp.buttons[7]?.value||0);
    const lt = gp.axes[2]!==undefined ? (ax(2)+1)/2 : (gp.buttons[6]?.value||0);
    return { steer: ax(0), accel: rt, brake: lt, handbrake: bt(0), nitro: bt(1) };
  }

  /* ======= Main loop ======= */
  let rearWheelPos = [new THREE.Vector3(), new THREE.Vector3()];
  function animate(){ const dt=Math.min(0.033, clock.getDelta()); step(dt); renderer.render(scene, camera); map.draw(); requestAnimationFrame(animate); }

  function step(dtReal){
    const dt = dtReal * timeScale;

    // —— INPUT ——
    const gp = readGamepad();
    const accelK  = (keys["w"]||keys["arrowup"]) ? 1 : (keys["s"]||keys["arrowdown"]) ? -0.7 : 0;
    const steerK  = (keys["a"]||keys["arrowleft"]) ? 1 : (keys["d"]||keys["arrowright"]) ? -1 : 0;
    const handbrake = keys[" "] || (gp && gp.handbrake);
    const boostKey  = keys["shift"] || (gp && gp.nitro);
    const accel = (gp ? Math.max(Math.abs(accelK), Math.abs(gp.accel - gp.brake)) * Math.sign((accelK|| (gp.accel - gp.brake))) : accelK);
    const steer = (gp && Math.abs(gp.steer) > Math.abs(steerK*0.9)) ? -gp.steer : steerK;

    // Steering & brakes
    playerVehicle.setSteeringValue(steer * 0.5, 0);
    playerVehicle.setSteeringValue(steer * 0.5, 1);
    for(let i=0;i<4;i++) playerVehicle.setBrake(handbrake ? 55 : 0, i);

    // Nitro (manual)
    const v = chassisBody.velocity; const horizSpeed = Math.sqrt(v.x*v.x + v.z*v.z);
    if (boostKey && nitro>0){
      nitro = Math.max(0, nitro - 0.35*dtReal);
      const dir = forwardVector(chassisBody);
      chassisBody.applyForce(new CANNON.Vec3(dir.x*2500, 0, dir.z*2500), chassisBody.position);
      const back = new THREE.Vector3(-dir.x, -dir.y, -dir.z);
      const p = new THREE.Vector3(chassisBody.position.x + back.x*2.2, chassisBody.position.y+0.5, chassisBody.position.z + back.z*2.2);
      particles.flame.spawn(p, back.multiplyScalar(8), 0.12, 0.9);
      camShake = Math.min(0.4, camShake + 0.02);
    } else nitro = Math.min(1, nitro + 0.12*dtReal);
    ui.nitroFill.style.width = (nitro*100).toFixed(1) + "%";

    // Animated floor texture offset
    floorTex.offset.y += (horizSpeed * 0.00035) * dtReal;

    // Engine force (player) — turbo boosts power briefly
    const traction = groundedPrev ? 1.0 : 0.25;
    const turboMul = turboT>0 ? 1.8 : 1.0;
    const engine = -accel * 3200 * traction * turboMul;
    playerVehicle.applyEngineForce(engine, 2);
    playerVehicle.applyEngineForce(engine, 3);

    // Anti‑wheelie: light stabilizer & downforce when launching or in turbo
    if (groundedPrev && (accel > 0.4 || turboT>0)){
      const sp = Math.sqrt(v.x*v.x+v.z*v.z);
      stabilizePitch(chassisBody, 1800);
      applyAero(chassisBody, sp, 0.28);
    }

    if (turboT>0){
      const dir = forwardVector(chassisBody);
      chassisBody.applyForce(new CANNON.Vec3(dir.x*450, 0, dir.z*450), chassisBody.position);
      const sp = Math.sqrt(v.x*v.x+v.z*v.z);
      applyAero(chassisBody, sp, 0.55);
      turboT = Math.max(0, turboT - dtReal);
    }

    // In‑air barrel roll
    if (!groundedPrev && (keys["arrowleft"] || keys["arrowright"])){
      const fwd = forwardVector(chassisBody);
      const rollTorque = (keys["arrowleft"] ? -1 : 1) * 1800;
      chassisBody.torque.x += fwd.x * rollTorque;
      chassisBody.torque.y += fwd.y * rollTorque;
      chassisBody.torque.z += fwd.z * rollTorque;
    }

    // —— AI pursuit —— //
    const pv = {x:chassisBody.velocity.x, z:chassisBody.velocity.z};
    if (botsEnabled){
      for (let i=0;i<aiCars.length;i++){
        const ai = aiCars[i];
        ai.repathT -= dtReal;
        if (ai.repathT<=0){
          ai.repathT = aiRepathBase() + Math.random()*0.2;
          const px=chassisBody.position.x, pz=chassisBody.position.z;
          const s = nearestNode(ai.body.position.x, ai.body.position.z), g = nearestNode(px + pv.x*0.8, pz + pv.z*0.8);
          const pathIdxs = aStar(s,g);
          ai.path = pathIdxs.map(k => ({x:nav.nodes[k].x, z:nav.nodes[k].z}));
          ai.pathIdx = 0;
        }

        const ax=ai.body.position.x, az=ai.body.position.z;
        const dxp = chassisBody.position.x - ax, dzp = chassisBody.position.z - az, distP = Math.hypot(dxp,dzp);
        const aiMax = aiTargetSpeed();

        // Predictive intercept with flank offset
        let lead = aiLeadFactor(distP, aiMax);
        const pvLen = Math.hypot(pv.x,pv.z) || 1, nx = pv.x/pvLen, nz = pv.z/pvLen;
        const leftx = -nz, leftz = nx;
        const flankOff = (6 + Math.min(16, distP*0.12)) * (1 + heat*0.08);
        let target = { x: chassisBody.position.x + pv.x * lead,
                       z: chassisBody.position.z + pv.z * lead };
        if (ai.role==="flankL"){ target.x += leftx*flankOff; target.z += leftz*flankOff; }
        if (ai.role==="flankR"){ target.x -= leftx*flankOff; target.z -= leftz*flankOff; }

        if (distP > 140 && ai.path.length){
          const wp = ai.path[Math.min(ai.pathIdx, ai.path.length-1)];
          const dwp = Math.hypot(wp.x-ax, wp.z-az);
          if (dwp < 10 && ai.pathIdx < ai.path.length-1) ai.pathIdx++;
          target.x = target.x*0.7 + wp.x*0.3; target.z = target.z*0.7 + wp.z*0.3;
        }

        const f = forwardVector(ai.body);
        const to = { x: target.x - ax, z: target.z - az };
        const dot = f.x*to.x + f.z*to.z, cross = f.x*to.z - f.z*to.x;
        let desired = -Math.atan2(cross, dot);
        const avoid = aiAvoidSteer(ai);
        desired += avoid.steer;

        ai.steerLP = ai.steerLP*0.6 + desired*0.4;
        let steerAI = Math.max(-aiSteerClamp(), Math.min(aiSteerClamp(), ai.steerLP));
        ai.veh.setSteeringValue(steerAI, 0);
        ai.veh.setSteeringValue(steerAI, 1);
        for(let w=0;w<4;w++) ai.veh.setBrake(0, w);

        const vA = ai.body.velocity; const spd = Math.hypot(vA.x, vA.z);
        let engineAI = aiEngineBase();
        const targetSpd = aiMax * (distP<55 ? 1.12 : 1.0);
        if (Math.abs(steerAI)>0.45) engineAI *= 0.62; else if (Math.abs(steerAI)>0.25) engineAI *= 0.82;
        if (spd > targetSpd) engineAI *= 0.5;
        const fwd = forwardVector(ai.body); if (fwd.y > 0.12) engineAI *= 0.55;
        ai.veh.applyEngineForce(engineAI, 2);
        ai.veh.applyEngineForce(engineAI, 3);

        applyAero(ai.body, spd, 0.45 * DIFF[diff].grip);
        stabilizePitch(ai.body, 2300);

        if (spd < 0.9) ai.stuckT += dtReal; else ai.stuckT = Math.max(0, ai.stuckT - dtReal*0.7);
        if (ai.stuckT>1.1 && ai.stuckT<1.6){ ai.veh.applyEngineForce(1200, 2); ai.veh.applyEngineForce(1200, 3); }
        if (ai.stuckT > 3.0){ resetAI(ai); ai.repathT=0.2; }
      }
    }

    // Physics
    world.step(1/60, dt, 3);

    // Sync visuals
    chassisMesh.position.copy(chassisBody.position);
    chassisMesh.quaternion.copy(chassisBody.quaternion);
    for (let i=0; i<playerVehicle.wheelInfos.length; i++){
      playerVehicle.updateWheelTransform(i);
      const t = playerVehicle.wheelInfos[i].worldTransform;
      playerWheelMeshes[i].position.set(t.position.x,t.position.y,t.position.z);
      playerWheelMeshes[i].quaternion.set(t.quaternion.x,t.quaternion.y,t.quaternion.z,t.quaternion.w);
      if (i>=2) rearWheelPos[i-2].set(t.position.x,t.position.y,t.position.z);
    }
    for (const ai of aiCars){
      ai.mesh.position.copy(ai.body.position);
      ai.mesh.quaternion.copy(ai.body.quaternion);
      for (let i=0;i<ai.veh.wheelInfos.length;i++){
        ai.veh.updateWheelTransform(i);
        const t = ai.veh.wheelInfos[i].worldTransform;
        ai.wheels[i].position.set(t.position.x,t.position.y,t.position.z);
        ai.wheels[i].quaternion.set(t.quaternion.x,t.quaternion.y,t.quaternion.z,t.quaternion.w);
      }
    }

    // Ground contact
    const onGroundPlayer = playerVehicle.wheelInfos.some(w => w.raycastResult && w.raycastResult.hasHit);
    groundedPrev = onGroundPlayer;

    // —— SCORING —— //
    // Drift + smoke
    {
      const fwd = forwardVector(chassisBody); const s = Math.sqrt(v.x*v.x+v.z*v.z);
      const dot = (v.x*fwd.x + v.z*fwd.z) / (Math.max(0.001,s)*Math.sqrt(fwd.x*fwd.x+fwd.z*fwd.z));
      const slip = Math.acos(Math.max(-1, Math.min(1, dot))) * 180/Math.PI;
      if (onGroundPlayer && s>4 && slip>18){
        driftTimer += dt;
        const driftPts = (slip/20) * (s/6) * 20 * dt; addScore(driftPts, "Drift");
        combo = Math.min(3.0, combo + 0.015); ui.combo.textContent = `Combo x${combo.toFixed(1)}`;
        for (const rp of rearWheelPos){
          particles.smoke.spawn(new THREE.Vector3(rp.x,rp.y+0.05,rp.z), new THREE.Vector3((Math.random()-0.5)*0.7,0.5,(Math.random()-0.5)*0.7), 0.45, 0.7);
        }
      } else { driftTimer = 0; }
    }

    // Airtime, flips
    if (!onGroundPlayer){
      if (!airborne){ airborne=true; airTime=0; rotAccum=0; lastQuat=chassisMesh.quaternion.clone(); }
      airTime += dt;
      const dq=lastQuat.clone().invert().multiply(chassisMesh.quaternion.clone());
      const angle=2*Math.acos(Math.max(-1,Math.min(1,dq.w)));
      rotAccum += angle; lastQuat.copy(chassisMesh.quaternion);
      ui.air.textContent = airTime.toFixed(1)+"s";
    } else if (airborne){
      const flips = Math.floor(rotAccum/(2*Math.PI));
      let pts = Math.round(airTime * 260);
      if (flips>0){ pts += flips * 1200; flash(`Flip x${flips}!`); audio.blip(520,.12,.25); }
      addScore(pts, "Airtime");
      if (airTime > 0.6) { combo = Math.min(3.0, combo + 0.2*(1+flips)); }
      ui.combo.textContent = `Combo x${combo.toFixed(1)}`;
      if (flips>=2 || airTime>1.2){ timeScale = 0.35; slowmoT = 0.55; ui.slowmo.style.display='block'; }
      airborne=false; airTime=0; ui.air.textContent="0.0s";
    } else {
      combo = Math.max(1.0, combo - 0.12*dtReal);
      ui.combo.textContent = `Combo x${combo.toFixed(1)}`;
    }

    // —— Boost pads —— //
    updateBoostPads(dtReal);

    // —— Pickups / Orbs & Heat —— //
    spinPickups(dtReal); checkPickups(); checkOrbs(); updateHeat(dtReal);

    // Power badge
    shieldT = Math.max(0, shieldT - dtReal);
    shieldMesh.visible = shieldT > 0;
    const ptxt = [];
    if (turboT>0) ptxt.push(`Turbo ${turboT.toFixed(1)}s`);
    if (shieldT>0) ptxt.push(`Shield ${shieldT.toFixed(1)}s`);
    ui.powerBadge.textContent = ptxt.length ? ptxt.join(" • ") : "—";

    // Particles update
    particles.smoke.update(dtReal);
    particles.flame.update(dtReal);
    particles.ring.update(dtReal);

    // HUD & audio
    const mph = Math.sqrt(v.x*v.x+v.z*v.z) * 2.237; ui.speed.textContent = Math.round(mph);
    ui.grade.style.opacity = Math.min(0.45, 0.10 + heat*0.06 + mph*0.0012);
    audio.engine(mph/140, 0.10 + (keys["w"]||keys["arrowup"] ? 0.12 : 0));

    // Tag / shield knockback
    if (botsEnabled){
      for (const ai of aiCars){
        const dx = ai.body.position.x - chassisBody.position.x;
        const dz = ai.body.position.z - chassisBody.position.z;
        const dist = Math.hypot(dx,dz);
        if (dist < CATCH_RADIUS){
          if (shieldT>0){
            const dir = new CANNON.Vec3(dx/dist, 0, dz/dist);
            ai.body.applyImpulse(new CANNON.Vec3(dir.x* -12, 4, dir.z* -12), ai.body.position);
            addScore(120, "Shield bump"); camShake = Math.min(0.5, camShake+0.2);
          } else { resetRound("Tagged!"); break; }
        }
      }
    }

    // Camera
    updateCamera(dtReal, mph);

    // Slow‑mo decay
    if (slowmoT>0){ slowmoT -= dtReal; if (slowmoT<=0){ timeScale=1; ui.slowmo.style.display='none'; } }

    camShake = Math.max(0, camShake - dtReal*0.8);
  }

  /* ======= Boost pads logic (re‑tuned) ======= */
  function updateBoostPads(dt){
    for (const pad of boosts){ pad.cool = Math.max(0, pad.cool - dt); }
    for (const pad of boosts){
      if (pad.cool>0) continue;
      const dx = chassisBody.position.x - pad.pos.x;
      const dz = chassisBody.position.z - pad.pos.z;
      const c = Math.cos(-pad.rotY), s = Math.sin(-pad.rotY);
      const lx = dx*c - dz*s, lz = dx*s + dz*c;
      if (Math.abs(lx) <= pad.size.x/2 && Math.abs(lz) <= pad.size.y/2){
        // Blend player's facing with pad's facing
        const playerF = forwardVector(chassisBody);
        const padF = { x: Math.sin(pad.rotY), z: Math.cos(pad.rotY) };
        const bx = playerF.x*0.6 + padF.x*0.4, bz = playerF.z*0.6 + padF.z*0.4;
        const len = Math.hypot(bx,bz)||1;
        const dir = { x: bx/len, z: bz/len };

        // Strong forward kick, gentler lift to avoid wheelies
        chassisBody.applyImpulse(new CANNON.Vec3(dir.x*22, 1.2, dir.z*22), chassisBody.position);
        nitro = Math.min(1, nitro + 0.75);
        turboT = Math.max(turboT, 1.8);
        pushRing(chassisBody.position, 2.8);
        particles.flame.spawn(new THREE.Vector3(chassisBody.position.x - dir.x*2, 1.0, chassisBody.position.z - dir.z*2), new THREE.Vector3(-dir.x*6,0,-dir.z*6), 0.14, 1.0);
        addScore(450, "Boost pad");
        audio.blip(820,.14,.28);
        camShake = Math.min(0.6, camShake + 0.08);

        pad.cool = 1.2;
      }
    }
  }

  /* ======= Aero / Stabilizers ======= */
  function applyAero(body, speed, k=0.4){
    const df = k * speed*speed;
    const fwd = forwardVector(body);
    const pFront = new CANNON.Vec3(body.position.x + fwd.x*1.6, body.position.y+0.4, body.position.z + fwd.z*1.6);
    const pRear  = new CANNON.Vec3(body.position.x - fwd.x*1.6, body.position.y+0.4, body.position.z - fwd.z*1.6);
    const F = new CANNON.Vec3(0, -df, 0);
    body.applyForce(F, pFront);
    body.applyForce(F, pRear);
  }
  function stabilizePitch(body, k=2000){
    const fwd = forwardVector(body);
    const right = rightVector(body);
    const pitch = fwd.y;
    body.torque.x += right.x * -pitch * k;
    body.torque.y += right.y * -pitch * k;
    body.torque.z += right.z * -pitch * k;
    body.angularVelocity.x *= 0.995;
    body.angularVelocity.y *= 0.997;
    body.angularVelocity.z *= 0.995;
  }

  /* ======= Camera ======= */
  function updateCamera(dt, mph){
    if (cameraMode==="chase"){
      const lookAhead = 0.02 * Math.min(60, mph);
      const forward = new THREE.Vector3(0,0,1).applyQuaternion(chassisMesh.quaternion);
      const up = new THREE.Vector3(0,1,0);
      const target = chassisMesh.position.clone().add(forward.clone().multiplyScalar(lookAhead));
      let desired = chassisMesh.position.clone()
        .add(up.multiplyScalar(1.6 + Math.min(2.2, mph/60)))
        .add(forward.multiplyScalar(-7.0 - Math.min(3.0, mph/40)));
      if (camShake>0){
        desired.add(new THREE.Vector3((Math.random()-0.5)*camShake,(Math.random()-0.5)*camShake*0.5,(Math.random()-0.5)*camShake));
      }
      const lerp = 1 - Math.pow(0.001, dt);
      camera.position.lerp(desired, lerp); camera.lookAt(target);
    } else {
      const fwd = new THREE.Vector3(0,0,1).applyQuaternion(chassisMesh.quaternion);
      const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), fwd).normalize();
      const pos = chassisMesh.position.clone().add(right.multiplyScalar(10)).add(new THREE.Vector3(0,6,0)).add(fwd.clone().multiplyScalar(10));
      camera.position.lerp(pos, 0.15); camera.lookAt(chassisMesh.position);
    }
  }

  /* ======= Reset (Heat kept) ======= */
  function resetAI(ai){
    ai.body.position.set(ai.spawn.x, 3, ai.spawn.z);
    ai.body.velocity.set(0,0,0);
    ai.body.angularVelocity.set(0,0,0);
    ai.body.quaternion.setFromEuler(0,0,0);
    ai.stuckT = 0; ai.path.length=0; ai.pathIdx=0; ai.repathT=0.2;
  }
  function resetPlayer(){
    chassisBody.position.set(0,3,-140);
    chassisBody.velocity.set(0,0,0);
    chassisBody.angularVelocity.set(0,0,0);
    chassisBody.quaternion.setFromEuler(0,0,0);
    chassisBody.wakeUp();
    combo = Math.max(1.0, combo * 0.8); ui.combo.textContent = `Combo x${combo.toFixed(1)}`;
    reconcileBotsToHeat();
  }
  function resetRound(reason){ if(reason){ flash(reason); } resetPlayer(); for (const ai of aiCars) resetAI(ai); }

  /* ======= Boot ======= */
  initThree();
  initPhysics();
  buildPlayer();
  reconcileBotsToHeat();
  ui.btnDiff.textContent = 'Difficulty: ' + DIFF[diff].name;
  clock = new THREE.Clock();
  animate();

})();
</script>
</body>
</html>
